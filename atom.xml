<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yan</title>
  <subtitle>aim higher</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-07-12T13:51:34.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>燕鹏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-HouseRobberIII</title>
    <link href="http://yoursite.com/2016/07/12/leetcode_house_robber_iii/"/>
    <id>http://yoursite.com/2016/07/12/leetcode_house_robber_iii/</id>
    <published>2016-07-12T11:55:41.000Z</published>
    <updated>2016-07-12T13:51:34.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/house-robber-iii/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一道dp题目，需要拆解子问题，分析如下:&lt;br&gt;&lt;img src=&quot;http://o9kchgjar.bkt.clouddn.com/Snip20160712_57.png&quot; alt=&quot;dp photo&quot;&gt;&lt;/p&gt;
&lt;p&gt;a点可抢劫的最大值，包括两种情况，包含a点、不包含a点。&lt;br&gt;包含a点，其左右节点就不能包含；&lt;br&gt;不包含a点，则为其左右节点可抢劫最大值之和。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;best_with(a) = a.val + best_without(b) + best_without(c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;best_without(a) = max(best_with(b),best_without(b)) + max(best_with(c),best_without(c))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;按照上面的解法，写出代码。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Definition for a binary tree node.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * public class TreeNode &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     int val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     TreeNode left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     TreeNode right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     TreeNode(int x) &amp;#123; val = x; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public int rob(TreeNode root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (root == null ) return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int selectCur = root.val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (root.left != null) selectCur += (rob(root.left.left)+rob(root.left.right));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (root.right != null) selectCur += (rob(root.right.left)+rob(root.right.right));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int unselectCur = rob(root.left)+rob(root.right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return Math.max(selectCur,unselectCur);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可是提交时，会有TLE。我们在计算子节点可抢劫的最大值时进行了重复计算。从下面的代码里，可以看出有重复计算。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rob(root.left.left)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rob(root.left)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用的方法：在计算节点可抢劫的最大值时，存储包含当前节点的最大值best_with和不包含当前节点的最大值best_without,返回一个数组。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Definition for a binary tree node.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * public class TreeNode &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     int val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     TreeNode left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     TreeNode right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     TreeNode(int x) &amp;#123; val = x; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public int rob(TreeNode root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	 int[] rst = &amp;#123;0,0&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	 rst = dfs(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return Math.max(rst[0],rst[1]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public int[] dfs(TreeNode root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int [] robber = &amp;#123;0,0&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (root != null)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int[] robLeft = dfs(root.left);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int[] robRight = dfs(root.right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            robber[0] = Math.max(robLeft[0],robLeft[1])+Math.max(robRight[0],robRight[1]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            robber[1] = root.val+robLeft[0]+robRight[0];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return robber;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;robber[1]存储的是在包含当前节点的情况下，当前节点可抢劫的最大值。&lt;br&gt;robber[0]存储的是在不包含当前节点情况下，当前节点可抢劫的最大值。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/house-robber-iii/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一道dp题目，需要拆解子问题，分析如下:&lt;br&gt;&lt;img s
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Coursera机器学习-linearRegression公式总结</title>
    <link href="http://yoursite.com/2016/07/05/coursera_machine_learning_lesson_1/"/>
    <id>http://yoursite.com/2016/07/05/coursera_machine_learning_lesson_1/</id>
    <published>2016-07-05T12:18:25.000Z</published>
    <updated>2016-07-05T13:59:47.000Z</updated>
    
    <content type="html">&lt;p&gt;假设函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o9kchgjar.bkt.clouddn.com/linear_regression_h_theta.gif&quot; alt=&quot;hypothesis function&quot;&gt;&lt;/p&gt;
&lt;p&gt;损失函数:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o9kchgjar.bkt.clouddn.com/linear_regression_cost_function.gif&quot; alt=&quot;cost function&quot;&gt;&lt;/p&gt;
&lt;p&gt;梯度下降:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o9kchgjar.bkt.clouddn.com/linear_regression_gradient_descent.gif&quot; alt=&quot;gradient descent&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;假设函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o9kchgjar.bkt.clouddn.com/linear_regression_h_theta.gif&quot; alt=&quot;hypothesis function&quot;&gt;&lt;/p&gt;
&lt;p&gt;损失函数:&lt;/p&gt;
&lt;p&gt;&lt;im
    
    </summary>
    
    
      <category term="coursera" scheme="http://yoursite.com/tags/coursera/"/>
    
      <category term="machinelearning" scheme="http://yoursite.com/tags/machinelearning/"/>
    
  </entry>
  
  <entry>
    <title>SparkSQL(dataFrame)为什么比rdd更高效</title>
    <link href="http://yoursite.com/2016/07/05/sparkSQL_vs_rdd/"/>
    <id>http://yoursite.com/2016/07/05/sparkSQL_vs_rdd/</id>
    <published>2016-07-05T10:00:55.000Z</published>
    <updated>2016-07-05T10:47:38.000Z</updated>
    
    <content type="html">&lt;p&gt;  Spark官方在介绍SparkSQL的概念时，如下：&lt;/p&gt;
&lt;p&gt;  SparkSQL是Spark中结构化数据处理的模型。不像Spark基础的RDDAPI，sparkSQL的接口提供了更丰富的信息，关于数据和优化后计算的结构。SparkSQL用这些信息来优化。&lt;/p&gt;
&lt;p&gt;  &lt;a href=&quot;http://spark.apache.org/docs/latest/sql-programming-guide.html#sql&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SparkSQL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  dataFrame的介绍如下：&lt;br&gt;  一个dataFrame是一个分布式数据集，它的数据被命名的列管理。它在概念上类似于数据库中的表，但更丰富。&lt;/p&gt;
&lt;p&gt;  在databrick的一篇slideshare中，有一张ppt，也进行了解释。&lt;br&gt;  &lt;img src=&quot;http://o9kchgjar.bkt.clouddn.com/Snip20160705_2.png&quot; alt=&quot;databrick ppt&quot;&gt;&lt;/p&gt;
&lt;p&gt;  处理bigdata最快的方式是不读取它。&lt;br&gt;  SparkSQL可以读取更少的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;转换成更高效的格式
用column列的格式
使用partition(例如，根据年份、月份)
使用数据统计跳过读取
把断言推向存储系统(例如，JDBC)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  &lt;a href=&quot;http://www.slideshare.net/databricks/spark-sqlsse2015public&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;databrick slideshare&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  Spark官方在介绍SparkSQL的概念时，如下：&lt;/p&gt;
&lt;p&gt;  SparkSQL是Spark中结构化数据处理的模型。不像Spark基础的RDDAPI，sparkSQL的接口提供了更丰富的信息，关于数据和优化后计算的结构。SparkSQL用这些信息来优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SparkSQL" scheme="http://yoursite.com/tags/SparkSQL/"/>
    
  </entry>
  
</feed>
