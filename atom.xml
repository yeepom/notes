<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yan</title>
  <subtitle>aim higher</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-11-21T07:03:54.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>燕鹏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>twoSum</title>
    <link href="http://yoursite.com/2016/11/21/twoSum/"/>
    <id>http://yoursite.com/2016/11/21/twoSum/</id>
    <published>2016-11-21T06:04:53.000Z</published>
    <updated>2016-11-21T07:03:54.000Z</updated>
    
    <content type="html">&lt;p&gt;leetcode上easy的一道题。&lt;/p&gt;
&lt;p&gt;用cpp跑了两种算法。&lt;/p&gt;
&lt;p&gt;1.先将拷贝一份vector。对新的数组排序，并找出相加等于target的对应值first、second。再在原始数组中扫一遍，找出first和second的相应位置。代码如下。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vector&amp;lt;int&amp;gt; nums_copy = nums;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vector&amp;lt;int&amp;gt; rst;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sort(nums_copy.begin(), nums_copy.end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        auto it = nums_copy.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        auto last_it = it + nums_copy.size()-1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int first,second;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(it != last_it)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int sum = *it + *last_it;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(sum &amp;lt; target)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                it++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else if(sum &amp;gt; target)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                last_it--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                first = *it;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                second = *last_it;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        it = nums.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(;it != nums.end(); it++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(*it == first)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                rst.push_back(it-nums.begin());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else if(*it == second)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                rst.push_back(it-nums.begin());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return rst;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结果：9ms，超过96.22%。&lt;/p&gt;
&lt;p&gt;2.使用map，存储&amp;lt;数值，数值的位置&amp;gt;。遍历整个数组。遍历过程中，其中map中key存储target－已遍历元素的值，value存储已遍历元素的位置。如果下一个元素在map中可以找到相应的key，则满足条件；如果下一个元素找不到相应的key，就将&lt;target-元素的值,元素的位置&gt;存入map中。代码如下。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        unordered_map&amp;lt;int,int&amp;gt; m;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vector&amp;lt;int&amp;gt; rst;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        auto it = nums.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        size_t i = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(;it != nums.end(); it++,i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            auto find_it = m.find(*it);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(find_it == m.end())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                m.insert(pair&amp;lt;int,int&amp;gt;(target-*it,i));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                rst.push_back(find_it-&amp;gt;second);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                rst.push_back(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return rst;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/target-元素的值,元素的位置&gt;&lt;/p&gt;
&lt;p&gt;结果：19ms，超过58.82%。这里使用了unordered_map，要比使用map快(29ms)。unordered_map是基于hash实现的，map是基于tree实现的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode上easy的一道题。&lt;/p&gt;
&lt;p&gt;用cpp跑了两种算法。&lt;/p&gt;
&lt;p&gt;1.先将拷贝一份vector。对新的数组排序，并找出相加等于target的对应值first、second。再在原始数组中扫一遍，找出first和second的相应位置。代码如下。&lt;/p
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>蓄水池抽样问题（Reservoir Sampling）</title>
    <link href="http://yoursite.com/2016/07/18/reservoir_sampling/"/>
    <id>http://yoursite.com/2016/07/18/reservoir_sampling/</id>
    <published>2016-07-18T04:59:09.000Z</published>
    <updated>2016-07-18T05:47:33.000Z</updated>
    
    <content type="html">&lt;p&gt;问题描述：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;从个元素中随机抽取个元素，但的个数无法事先确定。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在实际应用中，往往会遇到很大数据流的情况。因此，我们无法先保存整个数据流然后再从中选取，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而是期望有一种将数据流遍历一遍就得到所选取的元素，并且保证得到的元素是随机的算法。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;抽样算法：&lt;/p&gt;
&lt;p&gt;1.先选择n个元素中的前k个元素，保存在集合S中；&lt;/p&gt;
&lt;p&gt;2.从第j(k+1 &amp;lt;= j &amp;lt;= n)开始，随机生成一个数 random = random % j + 1，random的取值范围为1~j。如果random &amp;lt;= k，则留下该元素，在S中随机选择一个元素进行替换；如果random &amp;gt; k，则放弃该元素。&lt;/p&gt;
&lt;p&gt;3.重复2的步骤。&lt;/p&gt;
&lt;p&gt;证明：&lt;br&gt;    假定选择了k个元素&lt;br&gt;    从k+1个元素开始，对于第k+1个元素，留下的概率，k/(k+1);对于S中的任意元素，留下的概率，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o9kchgjar.bkt.clouddn.com/CodeCogsEqn%20%281%29.gif&quot; alt=&quot;k+1 photo&quot;&gt;&lt;/p&gt;
&lt;p&gt;   则对于任意第i个元素(k+1 &amp;lt;= i &amp;lt;= n)，对于第i个元素，留下的概率为k/i；对于S中的任意元素，留下的概率，&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;http://o9kchgjar.bkt.clouddn.com/CodeCogsEqn%20%282%29.gif&quot; alt=&quot;i photo&quot;&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;http://www.guokr.com/blog/745588/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.guokr.com/blog/745588/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.jobbole.com/42550/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.jobbole.com/42550/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;问题描述：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b
    
    </summary>
    
    
      <category term="probability" scheme="http://yoursite.com/tags/probability/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-HouseRobberIII</title>
    <link href="http://yoursite.com/2016/07/12/leetcode_house_robber_iii/"/>
    <id>http://yoursite.com/2016/07/12/leetcode_house_robber_iii/</id>
    <published>2016-07-12T11:55:41.000Z</published>
    <updated>2016-07-12T14:01:17.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/house-robber-iii/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一道dp题目，需要拆解子问题，分析如下:&lt;br&gt;&lt;img src=&quot;http://o9kchgjar.bkt.clouddn.com/Snip20160712_57.png&quot; alt=&quot;dp photo&quot;&gt;&lt;/p&gt;
&lt;p&gt;a点可抢劫的最大值，包括两种情况，包含a点、不包含a点。&lt;br&gt;包含a点，其左右节点就不能包含；&lt;br&gt;不包含a点，则为其左右节点可抢劫最大值之和。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;best_with(a) = a.val + best_without(b) + best_without(c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;best_without(a) = max(best_with(b),best_without(b)) + max(best_with(c),best_without(c))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;按照上面的解法，写出代码。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Definition for a binary tree node.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * public class TreeNode &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     int val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     TreeNode left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     TreeNode right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     TreeNode(int x) &amp;#123; val = x; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public int rob(TreeNode root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (root == null ) return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int selectCur = root.val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (root.left != null) selectCur += (rob(root.left.left)+rob(root.left.right));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (root.right != null) selectCur += (rob(root.right.left)+rob(root.right.right));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int unselectCur = rob(root.left)+rob(root.right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return Math.max(selectCur,unselectCur);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可是提交时，会有TLE。我们在计算子节点可抢劫的最大值时进行了重复计算。从下面的代码里，可以看出有重复计算。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rob(root.left.left)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rob(root.left)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用的方法：在计算节点可抢劫的最大值时，存储包含当前节点的最大值best_with和不包含当前节点的最大值best_without,返回一个数组。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Definition for a binary tree node.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * public class TreeNode &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     int val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     TreeNode left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     TreeNode right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     TreeNode(int x) &amp;#123; val = x; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public int rob(TreeNode root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	 int[] rst = &amp;#123;0,0&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	 rst = dfs(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return Math.max(rst[0],rst[1]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public int[] dfs(TreeNode root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int [] robber = &amp;#123;0,0&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (root != null)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int[] robLeft = dfs(root.left);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int[] robRight = dfs(root.right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            robber[0] = Math.max(robLeft[0],robLeft[1])+Math.max(robRight[0],robRight[1]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            robber[1] = root.val+robLeft[0]+robRight[0];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return robber;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;robber[1]存储的是在包含当前节点的情况下，当前节点可抢劫的最大值。&lt;br&gt;robber[0]存储的是在不包含当前节点情况下，当前节点可抢劫的最大值。&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;    &lt;a href=&quot;http://blog.csdn.net/happyaaaaaaaaaaa/article/details/50880121&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/happyaaaaaaaaaaa/article/details/50880121&lt;/a&gt;&lt;br&gt;    &lt;a href=&quot;https://docs.google.com/document/d/1NPojCYmFOSg-GvYfOKKS6dkp6VBNbjVmYho5nl8YI3M/edit#heading=h.8xfeu8ymemfz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://docs.google.com/document/d/1NPojCYmFOSg-GvYfOKKS6dkp6VBNbjVmYho5nl8YI3M/edit#heading=h.8xfeu8ymemfz&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/house-robber-iii/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一道dp题目，需要拆解子问题，分析如下:&lt;br&gt;&lt;img s
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Coursera机器学习-linearRegression公式总结</title>
    <link href="http://yoursite.com/2016/07/05/coursera_machine_learning_lesson_1/"/>
    <id>http://yoursite.com/2016/07/05/coursera_machine_learning_lesson_1/</id>
    <published>2016-07-05T12:18:25.000Z</published>
    <updated>2016-07-05T13:59:47.000Z</updated>
    
    <content type="html">&lt;p&gt;假设函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o9kchgjar.bkt.clouddn.com/linear_regression_h_theta.gif&quot; alt=&quot;hypothesis function&quot;&gt;&lt;/p&gt;
&lt;p&gt;损失函数:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o9kchgjar.bkt.clouddn.com/linear_regression_cost_function.gif&quot; alt=&quot;cost function&quot;&gt;&lt;/p&gt;
&lt;p&gt;梯度下降:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o9kchgjar.bkt.clouddn.com/linear_regression_gradient_descent.gif&quot; alt=&quot;gradient descent&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;假设函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o9kchgjar.bkt.clouddn.com/linear_regression_h_theta.gif&quot; alt=&quot;hypothesis function&quot;&gt;&lt;/p&gt;
&lt;p&gt;损失函数:&lt;/p&gt;
&lt;p&gt;&lt;im
    
    </summary>
    
    
      <category term="coursera" scheme="http://yoursite.com/tags/coursera/"/>
    
      <category term="machinelearning" scheme="http://yoursite.com/tags/machinelearning/"/>
    
  </entry>
  
  <entry>
    <title>SparkSQL(dataFrame)为什么比rdd更高效</title>
    <link href="http://yoursite.com/2016/07/05/sparkSQL_vs_rdd/"/>
    <id>http://yoursite.com/2016/07/05/sparkSQL_vs_rdd/</id>
    <published>2016-07-05T10:00:55.000Z</published>
    <updated>2016-07-05T10:47:38.000Z</updated>
    
    <content type="html">&lt;p&gt;  Spark官方在介绍SparkSQL的概念时，如下：&lt;/p&gt;
&lt;p&gt;  SparkSQL是Spark中结构化数据处理的模型。不像Spark基础的RDDAPI，sparkSQL的接口提供了更丰富的信息，关于数据和优化后计算的结构。SparkSQL用这些信息来优化。&lt;/p&gt;
&lt;p&gt;  &lt;a href=&quot;http://spark.apache.org/docs/latest/sql-programming-guide.html#sql&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SparkSQL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  dataFrame的介绍如下：&lt;br&gt;  一个dataFrame是一个分布式数据集，它的数据被命名的列管理。它在概念上类似于数据库中的表，但更丰富。&lt;/p&gt;
&lt;p&gt;  在databrick的一篇slideshare中，有一张ppt，也进行了解释。&lt;br&gt;  &lt;img src=&quot;http://o9kchgjar.bkt.clouddn.com/Snip20160705_2.png&quot; alt=&quot;databrick ppt&quot;&gt;&lt;/p&gt;
&lt;p&gt;  处理bigdata最快的方式是不读取它。&lt;br&gt;  SparkSQL可以读取更少的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;转换成更高效的格式
用column列的格式
使用partition(例如，根据年份、月份)
使用数据统计跳过读取
把断言推向存储系统(例如，JDBC)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  &lt;a href=&quot;http://www.slideshare.net/databricks/spark-sqlsse2015public&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;databrick slideshare&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  Spark官方在介绍SparkSQL的概念时，如下：&lt;/p&gt;
&lt;p&gt;  SparkSQL是Spark中结构化数据处理的模型。不像Spark基础的RDDAPI，sparkSQL的接口提供了更丰富的信息，关于数据和优化后计算的结构。SparkSQL用这些信息来优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SparkSQL" scheme="http://yoursite.com/tags/SparkSQL/"/>
    
  </entry>
  
</feed>
